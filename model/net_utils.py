import torch.nn as nn
import torch

class DenseBlock(nn.Module):
    """Dense Block as defined in:
    Huang, Gao, Zhuang Liu, Laurens Van Der Maaten, and Kilian Q. Weinberger. 
    "Densely connected convolutional networks." In Proceedings of the IEEE conference 
    on computer vision and pattern recognition, pp. 4700-4708. 2017.
    Only performs `valid` convolution.
    """

    def __init__(self, in_ch, unit_ksize, unit_ch, unit_count, split=1):
        super(DenseBlock, self).__init__()
        assert len(unit_ksize) == len(unit_ch), "Unbalance Unit Info"

        self.nr_unit = unit_count
        self.in_ch = in_ch
        self.unit_ch = unit_ch

        # ! For inference only so init values for batchnorm may not match tensorflow
        unit_in_ch = in_ch
        pad_vals = [v // 2 for v in unit_ksize]
        self.units = nn.ModuleList()
        for idx in range(unit_count):
            self.units.append(nn.Sequential(
                nn.BatchNorm2d(unit_in_ch, eps=1e-5),
                nn.ReLU(inplace=True),
                nn.Conv2d(
                    unit_in_ch,
                    unit_ch[0],
                    unit_ksize[0],
                    stride=1,
                    padding=pad_vals[0],
                    bias=False,
                ),
                nn.BatchNorm2d(unit_ch[0], eps=1e-5),
                nn.ReLU(inplace=True),
                nn.Conv2d(
                    unit_ch[0],
                    unit_ch[1],
                    unit_ksize[1],
                    stride=1,
                    padding=pad_vals[1],
                    bias=False,
                    groups=split,
                ),
            ))
            unit_in_ch += unit_ch[1]

        self.blk_bna = nn.Sequential(nn.BatchNorm2d(unit_in_ch, eps=1e-5), nn.ReLU(inplace=True))

    def out_ch(self):
        return self.in_ch + self.nr_unit * self.unit_ch[-1]

    def forward(self, prev_feat):
        for idx in range(self.nr_unit):
            new_feat = self.units[idx](prev_feat)
            prev_feat = torch.cat([prev_feat, new_feat], dim=1)
        prev_feat = self.blk_bna(prev_feat)

        return prev_feat

